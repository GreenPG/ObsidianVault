---
date: 2024-07-02
tags:
    -
hubs:
    - "[[Python]]"
    - "[[Testing]]"
urls:
    - https://docs.pytest.org/en/8.2.x/contents.html
    - https://realpython.com/pytest-python-testing/
---

# Pytest 

Pytest is python framework to deploy tests for Python project.

The advantages of pytest in comparaison with other testing framework like unittest are :
 - less boilerplate code
 - a nicer output
 - less to learn, with the use of `assert`
 - easier to manage state and dependencies
 - eay to filter tests
 - allow test parametrization
 - has a plugin-based architecture


 ## Fixtures : managing state and dependencies

 Fixtures are a way of providing data, test doubles or state setup to tests.
 It can be used when you have to reuse some code to initialize your tests multpiple times. You can this repeated code in a function
 decorated with @pytest.fixture to indicate that it is a pytest fixture.
 ```
 @pytest_fixture
 def example_fixture():
    fixture contente
    ...
 ```

To use the fixture by adding as an argument of your tests. You don't have to call the fixture function. The name of the fixture will act as it return value.
```
def test_with_fixture(example_fixture):
    assert f(example_fixture) == expected_result


def test_2(example_fixture):
    assert g(example_fixture) == expected_result
```

You should avoid fixtures for tests that requires slight variations in the data, or you risk to clutter your test suite with fixtures.

Fixtures are modular, so they can be imported, can import modules or fixtures, and depend on other fixtures. This way, you can compose suitable fixture abstraction 
for your project.
If you want to make fixtures available in your whole test suites without importing it, you can use a conftest.py file. Fixture presents in this file will be accessible
in all the module without importing it.
Pytest also provides a monkeypatch fixture to replace values and behaviors, that can be helpful when test a project using network communication, by example.

```
# conftest.py

import pytest
import requests

@pytest.fixture(autouse=True)
def disable_network_calls(monkeypatch):
    def stunted_get():
        raise RuntimeError("Network access not allowed during testing!")
    monkeypatch.setattr(requests, "get", lambda *args, **kwargs: stunted_get())
```
In this example, ```disable_network_calls()```, placed in conftest.py and with ```autouse=True``` option ensure that the network calls
will be disabled in every test in the suite. 

## Marks: categorizing tests

Pytest allow to define categories of tests and provides options for including or excluding categories when running a test suite.
Marking test is usefol for categorizing test by subsystem or dependencies. 
To ensure that you don't make a mistake using your marks, you can register them in the pytest project configuration file pytest.ini
and running pytest with the flag ```--strict-markers```--strict-markers
